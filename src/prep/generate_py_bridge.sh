#!/usr/bin/env bash
# generate_py_bridge.sh - Generate Python-Rubolt bridge code

set -euo pipefail

if [[ $# -lt 2 ]]; then
  echo "Usage: $0 <module.py> <output_bridge.c>"
  exit 1
fi

INPUT="$1"
OUTPUT="$2"

if [[ ! -f "$INPUT" ]]; then
  echo "Error: Module not found: $INPUT"
  exit 1
fi

MODULE_NAME=$(basename "$INPUT" .py)

echo "[bridge] Generating bridge for $INPUT -> $OUTPUT"

# Extract function signatures
FUNCS=$(grep -oP '^\s*def\s+\K\w+' "$INPUT" || echo "")

# Generate C bridge code
cat > "$OUTPUT" <<EOF
// Python-Rubolt Bridge for module: $MODULE_NAME
// Auto-generated by generate_py_bridge.sh

#include <Python.h>
#include "../shared/sdk/native/rubolt_api.h"

static PyObject* py_module = NULL;

// Initialize Python module
static int init_${MODULE_NAME}_module(void) {
    if (py_module != NULL) return 0;
    
    Py_Initialize();
    py_module = PyImport_ImportModule("$MODULE_NAME");
    
    if (py_module == NULL) {
        PyErr_Print();
        return -1;
    }
    return 0;
}

EOF

# Generate wrapper for each function
for func in $FUNCS; do
  cat >> "$OUTPUT" <<EOF
// Wrapper for Python function: $func
static RbValue rb_py_${func}(int argc, RbValue* argv) {
    if (init_${MODULE_NAME}_module() < 0) {
        rb_raise_error("Failed to load Python module: $MODULE_NAME");
        return rb_null();
    }
    
    PyObject* py_func = PyObject_GetAttrString(py_module, "$func");
    if (py_func == NULL) {
        rb_raise_error("Function not found: $func");
        return rb_null();
    }
    
    // Convert Rubolt args to Python args
    PyObject* py_args = PyTuple_New(argc);
    for (int i = 0; i < argc; i++) {
        // TODO: Type conversion based on rb_typeof(argv[i])
        PyTuple_SetItem(py_args, i, Py_None);
    }
    
    // Call Python function
    PyObject* result = PyObject_CallObject(py_func, py_args);
    Py_DECREF(py_args);
    Py_DECREF(py_func);
    
    if (result == NULL) {
        PyErr_Print();
        rb_raise_error("Python function call failed");
        return rb_null();
    }
    
    // TODO: Convert Python result to RbValue
    Py_DECREF(result);
    return rb_null();
}

EOF
done

# Generate module registration
cat >> "$OUTPUT" <<EOF
// Module registration
static RbModuleFunc ${MODULE_NAME}_funcs[] = {
EOF

first=true
for func in $FUNCS; do
  if [[ "$first" = true ]]; then
    first=false
  else
    echo "," >> "$OUTPUT"
  fi
  echo -n "    {\"$func\", rb_py_${func}}" >> "$OUTPUT"
done

cat >> "$OUTPUT" <<EOF

};

void rb_init_py_${MODULE_NAME}(void) {
    rb_register_module("python.$MODULE_NAME", ${MODULE_NAME}_funcs, 
                       sizeof(${MODULE_NAME}_funcs) / sizeof(RbModuleFunc));
}
EOF

echo "[bridge] Bridge code generated: $OUTPUT"
echo "[bridge] Wrapped functions: $FUNCS"
