// Complete Rubolt Language Showcase
// Demonstrates all advanced features: pattern matching, generics, error handling,
// JIT compilation, testing, package management, and standard library

import file
import json
import time
import http
import test

// =============================================================================
// GENERICS SYSTEM
// =============================================================================

// Generic data structures
class Optional<T> {
    value: T;
    has_value: bool;
    
    def init(value: T) {
        this.value = value;
        this.has_value = true;
    }
    
    def none() -> Optional<T> {
        let opt = Optional<T>(null);
        opt.has_value = false;
        return opt;
    }
    
    def map<U>(func: function(T) -> U) -> Optional<U> {
        if (this.has_value) {
            return Optional<U>(func(this.value));
        }
        return Optional<U>.none();
    }
    
    def unwrap_or(default: T) -> T {
        return this.has_value ? this.value : default;
    }
}

// Generic algorithms
def quicksort<T: Comparable>(arr: T[]) -> T[] {
    if (arr.length <= 1) return arr;
    
    let pivot = arr[arr.length / 2];
    let less = arr.filter(x => x < pivot);
    let equal = arr.filter(x => x == pivot);
    let greater = arr.filter(x => x > pivot);
    
    return quicksort(less) + equal + quicksort(greater);
}

// =============================================================================
// PATTERN MATCHING
// =============================================================================

type JsonValue = number | string | bool | null | dict | list;

def process_json(value: JsonValue) -> string {
    match value {
        null => "null value";
        true => "boolean true";
        false => "boolean false";
        x: number if x > 100 => "large number: " + x;
        x: number => "number: " + x;
        s: string if s.length > 10 => "long string: " + s.substring(0, 10) + "...";
        s: string => "string: " + s;
        {name, age} => "person named " + name + " aged " + age;
        {type: "user", ...data} => "user object with data";
        [head, ...tail] => "list starting with " + head + " (" + tail.length + " more)";
        [] => "empty list";
        _ => "unknown type";
    }
}

def analyze_data_structure(data: any) -> dict {
    match data {
        // Nested pattern matching
        {users: [{name, email}, ...rest]} => {
            return {
                type: "user_collection",
                first_user: name,
                total_users: rest.length + 1,
                has_emails: email != null
            };
        };
        
        // Guard patterns with complex conditions
        x: list if x.length > 0 && x.all(item => typeof(item) == "number") => {
            return {
                type: "number_array",
                length: x.length,
                sum: x.reduce((a, b) => a + b, 0),
                average: x.reduce((a, b) => a + b, 0) / x.length
            };
        };
        
        // Type patterns
        String => {type: "string", length: data.length};
        Number => {type: "number", value: data};
        
        _ => {type: "unknown", value: data};
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================

type Result<T, E> = Ok<T> | Error<E>;

class DatabaseError {
    message: string;
    code: number;
    
    def init(message: string, code: number) {
        this.message = message;
        this.code = code;
    }
}

class UserService {
    db_path: string;
    
    def init(db_path: string) {
        this.db_path = db_path;
    }
    
    def get_user(id: number) -> Result<dict, DatabaseError> {
        try {
            if (!file.exists(this.db_path)) {
                return Error(DatabaseError("Database file not found", 404));
            }
            
            let data = json.parse(file.read(this.db_path));
            let user = data.users.find(u => u.id == id);
            
            if (user == null) {
                return Error(DatabaseError("User not found", 404));
            }
            
            return Ok(user);
        } catch (FileNotFoundError e) {
            return Error(DatabaseError("Database unavailable: " + e.message, 500));
        } catch (JsonParseError e) {
            return Error(DatabaseError("Database corrupted: " + e.message, 500));
        }
    }
    
    def create_user(user_data: dict) -> Result<dict, DatabaseError> {
        try {
            // Validate required fields
            let required = ["name", "email"];
            for (field in required) {
                if (!user_data.has_key(field)) {
                    return Error(DatabaseError("Missing required field: " + field, 400));
                }
            }
            
            let data = file.exists(this.db_path) ? 
                      json.parse(file.read(this.db_path)) : 
                      {users: [], next_id: 1};
            
            user_data.id = data.next_id;
            user_data.created_at = time.now();
            
            data.users.append(user_data);
            data.next_id += 1;
            
            file.write(this.db_path, json.stringify(data));
            
            return Ok(user_data);
        } catch (Exception e) {
            return Error(DatabaseError("Failed to create user: " + e.message, 500));
        }
    }
}

// =============================================================================
// JIT OPTIMIZED FUNCTIONS
// =============================================================================

@jit_compile
def matrix_multiply(a: number[][], b: number[][]) -> number[][] {
    let rows_a = a.length;
    let cols_a = a[0].length;
    let cols_b = b[0].length;
    
    let result = [];
    for (i in 0..rows_a) {
        result[i] = [];
        for (j in 0..cols_b) {
            let sum = 0.0;
            for (k in 0..cols_a) {
                sum += a[i][k] * b[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}

@hot_path
def fibonacci_optimized(n: number) -> number {
    // This will be JIT compiled after multiple calls
    if (n <= 1) return n;
    
    let a = 0;
    let b = 1;
    for (i in 2..n + 1) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

// =============================================================================
// WEB API CLIENT WITH ERROR HANDLING
// =============================================================================

class ApiClient {
    base_url: string;
    timeout: number;
    
    def init(base_url: string, timeout: number = 30) {
        this.base_url = base_url;
        this.timeout = timeout;
    }
    
    def get<T>(endpoint: string) -> Result<T, string> {
        try {
            let url = this.base_url + endpoint;
            let response = http.get(url);
            
            if (response == null) {
                return Error("Network request failed");
            }
            
            let data = json.parse(response);
            return Ok(data);
        } catch (NetworkError e) {
            return Error("Network error: " + e.message);
        } catch (JsonParseError e) {
            return Error("Invalid JSON response: " + e.message);
        }
    }
    
    def post<T>(endpoint: string, data: any) -> Result<T, string> {
        try {
            let url = this.base_url + endpoint;
            let json_data = json.stringify(data);
            let response = http.post(url, json_data, "application/json");
            
            if (response == null) {
                return Error("Network request failed");
            }
            
            let result = json.parse(response);
            return Ok(result);
        } catch (Exception e) {
            return Error("Request failed: " + e.message);
        }
    }
}

// =============================================================================
// DATA PROCESSING PIPELINE
// =============================================================================

class Pipeline<T> {
    stages: function[];
    
    def init() {
        this.stages = [];
    }
    
    def add_stage(stage: function(T) -> T) -> Pipeline<T> {
        this.stages.append(stage);
        return this;
    }
    
    def add_filter(predicate: function(T) -> bool) -> Pipeline<T> {
        this.stages.append(data => predicate(data) ? data : null);
        return this;
    }
    
    def add_transform<U>(transformer: function(T) -> U) -> Pipeline<U> {
        let new_pipeline = Pipeline<U>();
        new_pipeline.stages = this.stages + [transformer];
        return new_pipeline;
    }
    
    def process(data: T[]) -> T[] {
        let result = data;
        
        for (stage in this.stages) {
            result = result
                .map(stage)
                .filter(item => item != null);
        }
        
        return result;
    }
}

// =============================================================================
// COMPREHENSIVE TESTING
// =============================================================================

def run_comprehensive_tests() -> void {
    // Unit tests
    test.suite("Generics System", () => {
        test.case("Optional type", () => {
            let some_value = Optional<number>(42);
            let none_value = Optional<number>.none();
            
            assert.true(some_value.has_value, "Should have value");
            assert.false(none_value.has_value, "Should not have value");
            assert.equal(some_value.unwrap_or(0), 42, "Should unwrap to 42");
            assert.equal(none_value.unwrap_or(0), 0, "Should use default");
        });
        
        test.case("Generic sorting", () => {
            let numbers = [3, 1, 4, 1, 5, 9, 2, 6];
            let sorted = quicksort(numbers);
            assert.equal(sorted, [1, 1, 2, 3, 4, 5, 6, 9], "Should sort numbers");
            
            let strings = ["banana", "apple", "cherry"];
            let sorted_strings = quicksort(strings);
            assert.equal(sorted_strings, ["apple", "banana", "cherry"], "Should sort strings");
        });
    });
    
    test.suite("Pattern Matching", () => {
        test.case("JSON processing", () => {
            assert.equal(process_json(42), "number: 42", "Should handle numbers");
            assert.equal(process_json(150), "large number: 150", "Should handle large numbers");
            assert.equal(process_json("hello"), "string: hello", "Should handle strings");
            assert.equal(process_json(null), "null value", "Should handle null");
        });
        
        test.case("Data structure analysis", () => {
            let user_data = {
                users: [
                    {name: "Alice", email: "alice@example.com"},
                    {name: "Bob", email: "bob@example.com"}
                ]
            };
            
            let analysis = analyze_data_structure(user_data);
            assert.equal(analysis.type, "user_collection", "Should identify user collection");
            assert.equal(analysis.first_user, "Alice", "Should extract first user");
            assert.equal(analysis.total_users, 2, "Should count users");
        });
    });
    
    test.suite("Error Handling", () => {
        test.case("User service operations", () => {
            let service = UserService("test_users.json");
            
            // Test user creation
            let user_data = {name: "Test User", email: "test@example.com"};
            let result = service.create_user(user_data);
            
            match result {
                Ok(user) => {
                    assert.not_null(user.id, "Should assign ID");
                    assert.not_null(user.created_at, "Should set creation time");
                };
                Error(e) => {
                    assert.fail("User creation should succeed: " + e.message);
                };
            }
        });
    });
    
    // Property-based tests
    test.property("Quicksort produces sorted output",
        test.generate.list(test.generate.int(0, 1000), 0, 100),
        (list) => {
            let sorted = quicksort(list);
            for (i in 0..sorted.length - 1) {
                if (sorted[i] > sorted[i + 1]) return false;
            }
            return true;
        }
    );
    
    // Benchmarks
    test.benchmark("Matrix multiplication", () => {
        let a = [[1, 2], [3, 4]];
        let b = [[5, 6], [7, 8]];
        matrix_multiply(a, b);
    }, {iterations: 1000});
    
    test.benchmark("Fibonacci (JIT optimized)", () => {
        fibonacci_optimized(30);
    }, {iterations: 100});
}

// =============================================================================
// MAIN DEMONSTRATION
// =============================================================================

def main() -> void {
    print("=== Rubolt Complete Language Showcase ===\n");
    
    // 1. Generics demonstration
    print("1. Generics System:");
    let numbers = [64, 34, 25, 12, 22, 11, 90];
    let sorted_numbers = quicksort(numbers);
    print("  Sorted numbers: " + sorted_numbers);
    
    let optional_value = Optional<string>("Hello, Generics!");
    let mapped = optional_value.map(s => s.upper());
    print("  Optional mapping: " + mapped.unwrap_or(""));
    
    // 2. Pattern matching demonstration
    print("\n2. Pattern Matching:");
    let test_values = [
        42,
        150,
        "short",
        "this is a very long string",
        {name: "Alice", age: 30},
        [1, 2, 3, 4, 5],
        null
    ];
    
    for (value in test_values) {
        print("  " + process_json(value));
    }
    
    // 3. Error handling demonstration
    print("\n3. Error Handling:");
    let service = UserService("demo_users.json");
    
    // Create test user
    let new_user = {name: "Demo User", email: "demo@rubolt.dev"};
    let create_result = service.create_user(new_user);
    
    match create_result {
        Ok(user) => {
            print("  Created user: " + user.name + " (ID: " + user.id + ")");
            
            // Try to get the user
            let get_result = service.get_user(user.id);
            match get_result {
                Ok(retrieved_user) => {
                    print("  Retrieved user: " + retrieved_user.name);
                };
                Error(e) => {
                    print("  Error retrieving user: " + e.message);
                };
            }
        };
        Error(e) => {
            print("  Error creating user: " + e.message);
        };
    }
    
    // 4. JIT compilation demonstration
    print("\n4. JIT Compilation:");
    let start_time = time.now_ms();
    
    // This will trigger JIT compilation after several calls
    for (i in 0..20) {
        fibonacci_optimized(25);
    }
    
    let jit_time = time.now_ms() - start_time;
    print("  Fibonacci (20 iterations): " + jit_time + "ms");
    
    // 5. Data pipeline demonstration
    print("\n5. Data Processing Pipeline:");
    let raw_data = [
        {name: "Alice", age: 25, score: 85},
        {name: "Bob", age: 17, score: 92},
        {name: "Charlie", age: 30, score: 78},
        {name: "Diana", age: 22, score: 95}
    ];
    
    let pipeline = Pipeline<dict>()
        .add_filter(person => person.age >= 18)  // Adults only
        .add_filter(person => person.score >= 80)  // High scores only
        .add_stage(person => {
            person.grade = person.score >= 90 ? "A" : "B";
            return person;
        });
    
    let processed = pipeline.process(raw_data);
    print("  Processed " + processed.length + " qualified candidates:");
    for (person in processed) {
        print("    " + person.name + " (Grade: " + person.grade + ")");
    }
    
    // 6. API client demonstration
    print("\n6. HTTP API Client:");
    let api = ApiClient("https://jsonplaceholder.typicode.com");
    let user_result = api.get<dict>("/users/1");
    
    match user_result {
        Ok(user) => {
            print("  Fetched user: " + user.name + " (" + user.email + ")");
        };
        Error(e) => {
            print("  API error: " + e);
        };
    }
    
    // 7. Run comprehensive tests
    print("\n7. Running Test Suite:");
    run_comprehensive_tests();
    
    print("\n=== Showcase Complete ===");
    print("Rubolt demonstrates modern language features:");
    print("✓ Pattern matching with guards and destructuring");
    print("✓ Generics with type constraints and inference");
    print("✓ Comprehensive error handling with Result types");
    print("✓ JIT compilation for performance optimization");
    print("✓ Rich standard library (file, JSON, HTTP, time)");
    print("✓ Testing framework with property-based testing");
    print("✓ Package management and dependency resolution");
    print("✓ Developer tools (formatter, linter, language server)");
}

// Run the demonstration
main();